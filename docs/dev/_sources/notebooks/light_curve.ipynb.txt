{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**This is a fixed-text formatted version of a Jupyter notebook**\n",
    "\n",
    "- Try online [![Binder](https://mybinder.org/badge.svg)](https://mybinder.org/v2/gh/gammapy/gammapy-webpage/master?urlpath=lab/tree/light_curve.ipynb)\n",
    "- You can contribute with your own notebooks in this\n",
    "[GitHub repository](https://github.com/gammapy/gammapy/tree/master/tutorials).\n",
    "- **Source files:**\n",
    "[light_curve.ipynb](../_static/notebooks/light_curve.ipynb) |\n",
    "[light_curve.py](../_static/notebooks/light_curve.py)\n",
    "</div>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Light curve estimation\n",
    "\n",
    "## Introduction\n",
    "\n",
    "This tutorial presents a new light curve estimator that works with dataset objects. We will demonstrate how to compute a light curve from 3D data cubes as well as 1D spectral data using the `MapDataset`, `SpectrumDatasetOnOff` and `LightCurveEstimator` classes. \n",
    "\n",
    "We will use the four Crab nebula observations from the [H.E.S.S. first public test data release](https://www.mpi-hd.mpg.de/hfm/HESS/pages/dl3-dr1/) and compute per-observation fluxes. The Crab nebula is not known to be variable at TeV energies, so we expect constant brightness within statistical and systematic errors.\n",
    "\n",
    "The main classes we will use are:\n",
    "\n",
    "* [gammapy.time.LightCurve](..\/api/gammapy.time.LightCurve.rst)\n",
    "* [gammapy.time.LightCurveEstimator](..\/api/gammapy.time.LightCurveEstimator.rst)\n",
    "\n",
    "## Setup\n",
    "\n",
    "As usual, we'll start with some general imports..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import astropy.units as u\n",
    "from astropy.coordinates import SkyCoord\n",
    "from astropy.time import Time\n",
    "import logging\n",
    "\n",
    "log = logging.getLogger(__name__)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let's import gammapy specific classes and functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from gammapy.data import ObservationFilter, DataStore\n",
    "from gammapy.modeling.models import PowerLawSpectralModel\n",
    "from gammapy.modeling.models import PointSpatialModel\n",
    "from gammapy.modeling.models import SkyModel, BackgroundModel\n",
    "from gammapy.cube import PSFKernel, MapDatasetMaker, MapDataset\n",
    "from gammapy.maps import WcsGeom, MapAxis\n",
    "from gammapy.irf import make_mean_psf, make_mean_edisp\n",
    "from gammapy.time import LightCurveEstimator"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Select the data\n",
    "\n",
    "We look for relevant observations in the datastore."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_store = DataStore.from_file(\n",
    "    \"$GAMMAPY_DATA/hess-dl3-dr1/hess-dl3-dr3-with-background.fits.gz\"\n",
    ")\n",
    "mask = data_store.obs_table[\"TARGET_NAME\"] == \"Crab\"\n",
    "obs_ids = data_store.obs_table[\"OBS_ID\"][mask].data\n",
    "crab_obs = data_store.get_observations(obs_ids)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define time intervals\n",
    "We create a list of time intervals. Here we use one time bin per observation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_intervals = [(obs.tstart, obs.tstop) for obs in crab_obs]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3D data reduction \n",
    "\n",
    "### Define the analysis geometry\n",
    "\n",
    "Here we define the geometry used in the analysis. We use the same WCS map structure but we use two different binnings for reco and true energy axes. This allows for a broader coverage of the response."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Target definition\n",
    "target_position = SkyCoord(ra=83.63308, dec=22.01450, unit=\"deg\")\n",
    "\n",
    "# Define geoms\n",
    "emin, emax = [0.7, 10] * u.TeV\n",
    "energy_axis = MapAxis.from_bounds(\n",
    "    emin.value, emax.value, 10, unit=\"TeV\", name=\"energy\", interp=\"log\"\n",
    ")\n",
    "geom = WcsGeom.create(\n",
    "    skydir=target_position,\n",
    "    binsz=0.02,\n",
    "    width=(2, 2),\n",
    "    coordsys=\"CEL\",\n",
    "    proj=\"CAR\",\n",
    "    axes=[energy_axis],\n",
    ")\n",
    "\n",
    "etrue_axis = MapAxis.from_bounds(\n",
    "    0.1, 20, 20, unit=\"TeV\", name=\"energy\", interp=\"log\"\n",
    ")\n",
    "\n",
    "geom_true = WcsGeom.create(\n",
    "    skydir=target_position,\n",
    "    binsz=0.2,\n",
    "    width=(2, 2),\n",
    "    coordsys=\"CEL\",\n",
    "    proj=\"CAR\",\n",
    "    axes=[etrue_axis],\n",
    ")\n",
    "\n",
    "offset_max = 2 * u.deg"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Define the 3D model \n",
    "\n",
    "The light curve is based on a 3D fit of a map dataset in time bins. We therefore need to define the source model to be applied. Here a point source with power law spectrum. We freeze its parameters assuming they were previously extracted"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define the source model - Use a pointsource + integrated power law model to directly get flux\n",
    "\n",
    "spatial_model = PointSpatialModel(\n",
    "    lon_0=target_position.ra, lat_0=target_position.dec, frame=\"icrs\"\n",
    ")\n",
    "\n",
    "spectral_model = PowerLawSpectralModel(\n",
    "    index=2.6,\n",
    "    amplitude=2.0e-11 * u.Unit(\"1 / (cm2 s TeV)\"),\n",
    "    reference=1 * u.TeV,\n",
    ")\n",
    "spectral_model.parameters[\"index\"].frozen = False\n",
    "\n",
    "sky_model = SkyModel(\n",
    "    spatial_model=spatial_model, spectral_model=spectral_model, name=\"\"\n",
    ")\n",
    "sky_model.parameters[\"lon_0\"].frozen = True\n",
    "sky_model.parameters[\"lat_0\"].frozen = True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Make the map datasets\n",
    "\n",
    "The following function is in charge of the MapDataset production. It will later be fully covered in the data reduction chain "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we perform the actual data reduction in time bins"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/adonath/software/anaconda3/envs/gammapy-dev/lib/python3.7/site-packages/astropy/units/quantity.py:466: RuntimeWarning: invalid value encountered in true_divide\n",
      "  result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n",
      "/Users/adonath/github/adonath/gammapy/gammapy/cube/psf_kernel.py:109: RuntimeWarning: invalid value encountered in true_divide\n",
      "  img += vals.value / vals.sum().value\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 3.25 s, sys: 195 ms, total: 3.44 s\n",
      "Wall time: 3.5 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "datasets = []\n",
    "\n",
    "maker = MapDatasetMaker(geom=geom, geom_true=geom_true, offset_max=offset_max)\n",
    "\n",
    "for time_interval in time_intervals:\n",
    "    # get filtered observation lists in time interval\n",
    "    observations = crab_obs.select_time(time_interval)\n",
    "\n",
    "    # Proceed with further analysis only if there are observations\n",
    "    # in the selected time window\n",
    "    if len(observations) == 0:\n",
    "        log.warning(\n",
    "            \"No observations found in time interval:\"\n",
    "            \"{t_min} - {t_max}\".format(\n",
    "                t_min=time_interval[0], t_max=time_interval[1]\n",
    "            )\n",
    "        )\n",
    "        continue\n",
    "\n",
    "    stacked = MapDataset.create(geom=geom, geom_irf=geom_true)\n",
    "\n",
    "    for obs in observations:\n",
    "        dataset = maker.run(obs)\n",
    "        stacked.stack(dataset)\n",
    "\n",
    "    # TODO: remove once IRF maps are handled correctly in fit\n",
    "    stacked.edisp = stacked.edisp.get_energy_dispersion(\n",
    "        position=target_position, e_reco=energy_axis.edges\n",
    "    )\n",
    "\n",
    "    geom_psf = geom_true.to_binsz(binsz=0.02)\n",
    "    stacked.psf = stacked.psf.get_psf_kernel(\n",
    "        position=target_position, geom=geom_psf, max_radius=\"0.3 deg\"\n",
    "    )\n",
    "\n",
    "    stacked.counts.meta[\"t_start\"] = time_interval[0]\n",
    "    stacked.counts.meta[\"t_stop\"] = time_interval[1]\n",
    "    datasets.append(stacked)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Light Curve estimation: the 3D case\n",
    "\n",
    "Now that we have created the datasets we assign them the model to be fitted:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "for dataset in datasets:\n",
    "    # Copy the source model\n",
    "    model = sky_model.copy(name=\"crab\")\n",
    "    dataset.model = model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now create the light curve estimator by passing it the list of datasets. \n",
    "We can optionally ask for parameters reoptimization during fit, e.g. to fit background normalization in each time bin."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "lc_maker = LightCurveEstimator(datasets, source=\"crab\", reoptimize=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We now run the estimator once we pass it the energy interval on which to compute the integral flux of the source."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 16.8 s, sys: 274 ms, total: 17 s\n",
      "Wall time: 17.1 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "lc = lc_maker.run(e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The LightCurve object contains a table which we can explore."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<i>Table length=4</i>\n",
       "<table id=\"table4735734504\" class=\"table-striped table-bordered table-condensed\">\n",
       "<thead><tr><th>time_min</th><th>time_max</th><th>flux</th><th>flux_err</th></tr></thead>\n",
       "<thead><tr><th></th><th></th><th>1 / (cm2 s)</th><th>1 / (cm2 s)</th></tr></thead>\n",
       "<thead><tr><th>float64</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>\n",
       "<tr><td>53343.92234009259</td><td>53343.94186555556</td><td>2.5914432306867157e-11</td><td>1.9913169670932482e-12</td></tr>\n",
       "<tr><td>53343.95421509259</td><td>53343.97369425926</td><td>2.2982096228693447e-11</td><td>1.908267613477501e-12</td></tr>\n",
       "<tr><td>53345.96198129629</td><td>53345.98149518518</td><td>2.9587632607472014e-11</td><td>2.6236539536076096e-12</td></tr>\n",
       "<tr><td>53347.913196574074</td><td>53347.93271046296</td><td>2.750137623507771e-11</td><td>2.4994396055471656e-12</td></tr>\n",
       "</table>"
      ],
      "text/plain": [
       "<Table length=4>\n",
       "     time_min           time_max     ...        flux_err       \n",
       "                                     ...      1 / (cm2 s)      \n",
       "     float64            float64      ...        float64        \n",
       "------------------ ----------------- ... ----------------------\n",
       " 53343.92234009259 53343.94186555556 ... 1.9913169670932482e-12\n",
       " 53343.95421509259 53343.97369425926 ...  1.908267613477501e-12\n",
       " 53345.96198129629 53345.98149518518 ... 2.6236539536076096e-12\n",
       "53347.913196574074 53347.93271046296 ... 2.4994396055471656e-12"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lc.table[\"time_min\", \"time_max\", \"flux\", \"flux_err\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We finally plot the light curve"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.axes._subplots.AxesSubplot at 0x11a4674e0>"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "lc.plot(marker=\"o\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performing the same analysis with 1D spectra\n",
    "\n",
    "### First the relevant imports\n",
    "\n",
    "We import the missing classes for spectral data reduction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "from regions import CircleSkyRegion\n",
    "from astropy.coordinates import Angle\n",
    "from gammapy.spectrum import (\n",
    "    SpectrumExtraction,\n",
    "    ReflectedRegionsBackgroundEstimator,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Defining the geometry\n",
    "\n",
    "We need to define the ON extraction region. We will keep the same reco and true energy axes as in 3D."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Target definition\n",
    "on_region_radius = Angle(\"0.11 deg\")\n",
    "on_region = CircleSkyRegion(center=target_position, radius=on_region_radius)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Extracting the background\n",
    "\n",
    "We perform here an ON - OFF measurement with reflected regions. We perform first the background extraction. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "bkg_estimator = ReflectedRegionsBackgroundEstimator(\n",
    "    on_region=on_region, observations=crab_obs\n",
    ")\n",
    "bkg_estimator.run()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creation of the datasets\n",
    "\n",
    "We now apply spectral extraction to create the datasets. \n",
    "\n",
    "NB: we are using here time intervals defined by the observations start and stop times. The standard observation based spectral extraction is therefore defined in the right time bins. \n",
    "\n",
    "A proper time resolved spectral extraction will be included in a coming gammapy release."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/adonath/github/adonath/gammapy/gammapy/spectrum/extract.py:232: RuntimeWarning: invalid value encountered in true_divide\n",
      "  self.containment = new_aeff.data.data.value / self._aeff.data.data.value\n"
     ]
    }
   ],
   "source": [
    "# Note that we are not performing the extraction in time bins\n",
    "extraction = SpectrumExtraction(\n",
    "    observations=crab_obs,\n",
    "    bkg_estimate=bkg_estimator.result,\n",
    "    containment_correction=True,\n",
    "    e_reco=energy_axis.edges,\n",
    "    e_true=etrue_axis.edges,\n",
    ")\n",
    "extraction.run()\n",
    "datasets_1d = extraction.spectrum_observations\n",
    "\n",
    "# we need to set the times manually for now\n",
    "for dataset, time_interval in zip(datasets_1d, time_intervals):\n",
    "    dataset.counts.meta = dict()\n",
    "    dataset.counts.meta[\"t_start\"] = time_interval[0]\n",
    "    dataset.counts.meta[\"t_stop\"] = time_interval[1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Light Curve estimation for 1D spectra\n",
    "\n",
    "Now that we've reduced the 1D data we assign again the model to the datasets "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "for dataset in datasets_1d:\n",
    "    # Copy the source model\n",
    "    model = spectral_model.copy()\n",
    "    model.name = \"crab\"\n",
    "    dataset.model = model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now call the LightCurveEstimator in a perfectly identical manner."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "lc_maker_1d = LightCurveEstimator(datasets_1d, source=\"crab\", reoptimize=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 204 ms, sys: 8.67 ms, total: 212 ms\n",
      "Wall time: 206 ms\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "lc_1d = lc_maker_1d.run(e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Compare results\n",
    "\n",
    "Finally we compare the result for the 1D and 3D lightcurve in a single figure:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11c3286d8>"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "ax = lc_1d.plot(marker=\"o\", label=\"1D\")\n",
    "lc.plot(ax=ax, marker=\"o\", label=\"3D\")\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  },
  "nbsphinx": {
   "orphan": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
