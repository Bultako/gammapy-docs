{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**This is a fixed-text formatted version of a Jupyter notebook**\n",
    "\n",
    "- Try online [![Binder](https://mybinder.org/badge.svg)](https://mybinder.org/v2/gh/gammapy/gammapy-webpage/master?urlpath=lab/tree/light_curve.ipynb)\n",
    "- You can contribute with your own notebooks in this\n",
    "[GitHub repository](https://github.com/gammapy/gammapy/tree/master/tutorials).\n",
    "- **Source files:**\n",
    "[light_curve.ipynb](../_static/notebooks/light_curve.ipynb) |\n",
    "[light_curve.py](../_static/notebooks/light_curve.py)\n",
    "</div>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Light curve estimation\n",
    "\n",
    "## Introduction\n",
    "\n",
    "This tutorial presents a new light curve estimator that works with dataset objects. We will demonstrate how to compute a `~gammapy.time.LightCurve` from 3D data cubes as well as 1D spectral data using the `~gammapy.cube.MapDataset`, `~gammapy.spectrum.SpectrumDatasetOnOff` and `~gammapy.time.LightCurveEstimator` classes. \n",
    "\n",
    "We will compute two LCs: one per observation and one by night for which you have to provide the time intervals\n",
    "    \n",
    "We will use the four Crab nebula observations from the [H.E.S.S. first public test data release](https://www.mpi-hd.mpg.de/hfm/HESS/pages/dl3-dr1/) and compute per-observation fluxes. The Crab nebula is not known to be variable at TeV energies, so we expect constant brightness within statistical and systematic errors.\n",
    "\n",
    "## Setup\n",
    "\n",
    "As usual, we'll start with some general imports..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "import astropy.units as u\n",
    "from astropy.coordinates import SkyCoord\n",
    "import logging\n",
    "\n",
    "from astropy.time import Time\n",
    "\n",
    "log = logging.getLogger(__name__)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let's import gammapy specific classes and functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from gammapy.data import DataStore\n",
    "from gammapy.modeling.models import PowerLawSpectralModel\n",
    "from gammapy.modeling.models import PointSpatialModel\n",
    "from gammapy.modeling.models import SkyModel\n",
    "from gammapy.maps import WcsGeom, MapAxis\n",
    "from gammapy.time import LightCurveEstimator\n",
    "from gammapy.analysis import Analysis, AnalysisConfig"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Analysis configuration \n",
    "For the 1D and 3D extraction, we will use the same CrabNebula configuration than in the notebook analysis_1.ipynb using the high level interface of Gammapy.\n",
    "\n",
    "From the high level interface, the datareduction for those observations is performed as followed"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3D data reduction + Fit\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Data reduction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Setting logging config: {'level': 'INFO', 'filename': None, 'filemode': None, 'format': None, 'datefmt': None}\n",
      "Fetching observations.\n",
      "4 observations were selected.\n",
      "Creating geometry.\n",
      "Creating datasets.\n",
      "Processing observation 23592\n",
      "Processing observation 23523\n",
      "Processing observation 23526\n",
      "Processing observation 23559\n"
     ]
    }
   ],
   "source": [
    "conf_3d = AnalysisConfig.from_template(\"3d\")\n",
    "# We want to extract the data by observation and therefore to not stack them\n",
    "conf_3d.datasets.stack = False\n",
    "# Fixing more physical binning\n",
    "conf_3d.datasets.geom.axes.energy.min = \"0.7 TeV\"\n",
    "conf_3d.datasets.geom.axes.energy.max = \"10 TeV\"\n",
    "conf_3d.datasets.geom.axes.energy.nbins = 10\n",
    "conf_3d.datasets.geom.axes.energy_true.min = \"0.1 TeV\"\n",
    "conf_3d.datasets.geom.axes.energy_true.max = \"20 TeV\"\n",
    "conf_3d.datasets.geom.axes.energy.nbins = 20\n",
    "conf_3d.datasets.geom.wcs.fov = {\"width\": \"2 deg\", \"height\": \"2 deg\"}\n",
    "conf_3d.datasets.geom.wcs.binsize = \"0.02 deg\"\n",
    "\n",
    "ana_3d = Analysis(conf_3d)\n",
    "ana_3d.get_observations()\n",
    "ana_3d.get_datasets()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### 3D Fit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Define the model to be fitted"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "target_position = SkyCoord(ra=83.63308, dec=22.01450, unit=\"deg\")\n",
    "spatial_model = PointSpatialModel(\n",
    "    lon_0=target_position.ra, lat_0=target_position.dec, frame=\"icrs\"\n",
    ")\n",
    "spectral_model = PowerLawSpectralModel(\n",
    "    index=2.6,\n",
    "    amplitude=2.0e-11 * u.Unit(\"1 / (cm2 s TeV)\"),\n",
    "    reference=1 * u.TeV,\n",
    ")\n",
    "spectral_model.parameters[\"index\"].frozen = False\n",
    "sky_model = SkyModel(\n",
    "    spatial_model=spatial_model, spectral_model=spectral_model, name=\"crab\"\n",
    ")\n",
    "sky_model.parameters[\"lon_0\"].frozen = True\n",
    "sky_model.parameters[\"lat_0\"].frozen = True"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We assign them the model to be fitted to each dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Reading model.\n",
      "SkyModels\n",
      "\n",
      "Component 0: SkyModel\n",
      "\n",
      "   name     value   error      unit         min        max    frozen\n",
      "--------- --------- ----- -------------- ---------- --------- ------\n",
      "    lon_0 8.363e+01   nan            deg        nan       nan   True\n",
      "    lat_0 2.201e+01   nan            deg -9.000e+01 9.000e+01   True\n",
      "    index 2.600e+00   nan                       nan       nan  False\n",
      "amplitude 2.000e-11   nan cm-2 s-1 TeV-1        nan       nan  False\n",
      "reference 1.000e+00   nan            TeV        nan       nan   True\n",
      "\n",
      "\t\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "model = {}\n",
    "model[\"components\"] = [sky_model.to_dict()]\n",
    "ana_3d.set_model(model=model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Do the fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Fitting datasets.\n",
      "OptimizeResult\n",
      "\n",
      "\tbackend    : minuit\n",
      "\tmethod     : minuit\n",
      "\tsuccess    : True\n",
      "\tmessage    : Optimization terminated successfully.\n",
      "\tnfev       : 183\n",
      "\ttotal stat : 28990.06\n",
      "\n"
     ]
    }
   ],
   "source": [
    "ana_3d.run_fit()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1D data reduction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Data reduction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Setting logging config: {'level': 'INFO', 'filename': None, 'filemode': None, 'format': None, 'datefmt': None}\n",
      "Fetching observations.\n",
      "4 observations were selected.\n",
      "Reducing spectrum datasets.\n",
      "WARNING: AstropyDeprecationWarning: The truth value of a Quantity is ambiguous. In the future this will raise a ValueError. [astropy.units.quantity]\n",
      "AstropyDeprecationWarning: The truth value of a Quantity is ambiguous. In the future this will raise a ValueError.\n",
      "Processing observation 23592\n",
      "Processing observation 23523\n",
      "Processing observation 23526\n",
      "Processing observation 23559\n"
     ]
    }
   ],
   "source": [
    "conf_1d = AnalysisConfig.from_template(\"1d\")\n",
    "# We want to extract the data by observation and therefore to not stack them\n",
    "conf_1d.datasets.stack = False\n",
    "conf_1d.datasets.containment_correction = True\n",
    "conf_1d.datasets.geom.axes.energy.min = \"0.7 TeV\"\n",
    "conf_1d.datasets.geom.axes.energy.min = \"40 TeV\"\n",
    "conf_1d.datasets.geom.axes.energy.nbins = 40\n",
    "\n",
    "ana_1d = Analysis(conf_1d)\n",
    "ana_1d.get_observations()\n",
    "ana_1d.get_datasets()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 1D Fit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We assign the spectral model to be fitted to each dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Reading model.\n",
      "SkyModels\n",
      "\n",
      "Component 0: SkyModel\n",
      "\n",
      "   name     value   error      unit         min        max    frozen\n",
      "--------- --------- ----- -------------- ---------- --------- ------\n",
      "    lon_0 8.363e+01   nan            deg        nan       nan   True\n",
      "    lat_0 2.201e+01   nan            deg -9.000e+01 9.000e+01   True\n",
      "    index 2.600e+00   nan                       nan       nan  False\n",
      "amplitude 2.000e-11   nan cm-2 s-1 TeV-1        nan       nan  False\n",
      "reference 1.000e+00   nan            TeV        nan       nan   True\n",
      "\n",
      "\t\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "model = {}\n",
    "model[\"components\"] = [sky_model.to_dict()]\n",
    "ana_1d.set_model(model=model)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Do the fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Fitting datasets.\n",
      "OptimizeResult\n",
      "\n",
      "\tbackend    : minuit\n",
      "\tmethod     : minuit\n",
      "\tsuccess    : True\n",
      "\tmessage    : Optimization terminated successfully.\n",
      "\tnfev       : 71\n",
      "\ttotal stat : 7.79\n",
      "\n"
     ]
    }
   ],
   "source": [
    "ana_1d.run_fit()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Light Curve estimation: by observation\n",
    "We can now create the light curve estimator by passing it the list of datasets. We can optionally ask for parameters reoptimization during fit, e.g. to fit background normalization in each time bin.\n",
    "\n",
    "By default, the LightCurveEstimator is performed by dataset, here one dataset=one observation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "lc_maker_3d = LightCurveEstimator(\n",
    "    ana_3d.datasets, source=\"crab\", reoptimize=True\n",
    ")\n",
    "lc_3d = lc_maker_3d.run(e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The LightCurve object contains a table which we can explore."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<i>Table length=4</i>\n",
       "<table id=\"table4738156976\" class=\"table-striped table-bordered table-condensed\">\n",
       "<thead><tr><th>time_min</th><th>time_max</th><th>flux</th><th>flux_err</th></tr></thead>\n",
       "<thead><tr><th></th><th></th><th>1 / (cm2 s)</th><th>1 / (cm2 s)</th></tr></thead>\n",
       "<thead><tr><th>float64</th><th>float64</th><th>float64</th><th>float64</th></tr></thead>\n",
       "<tr><td>53343.92234009259</td><td>53343.94186555556</td><td>2.257764047926613e-11</td><td>2.2539839993326526e-12</td></tr>\n",
       "<tr><td>53343.95421509259</td><td>53343.97369425926</td><td>2.1887033854460022e-11</td><td>2.230520428131556e-12</td></tr>\n",
       "<tr><td>53345.96198129629</td><td>53345.98149518518</td><td>2.369606272628354e-11</td><td>2.8817140488507127e-12</td></tr>\n",
       "<tr><td>53347.913196574074</td><td>53347.93271046296</td><td>2.71583357312887e-11</td><td>3.0075943809069773e-12</td></tr>\n",
       "</table>"
      ],
      "text/plain": [
       "<Table length=4>\n",
       "     time_min           time_max     ...        flux_err       \n",
       "                                     ...      1 / (cm2 s)      \n",
       "     float64            float64      ...        float64        \n",
       "------------------ ----------------- ... ----------------------\n",
       " 53343.92234009259 53343.94186555556 ... 2.2539839993326526e-12\n",
       " 53343.95421509259 53343.97369425926 ...  2.230520428131556e-12\n",
       " 53345.96198129629 53345.98149518518 ... 2.8817140488507127e-12\n",
       "53347.913196574074 53347.93271046296 ... 3.0075943809069773e-12"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lc_3d.table[\"time_min\", \"time_max\", \"flux\", \"flux_err\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If you want to add a fit range for each of you time intervals when computing the LC."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "e_min_fit = 0.8 * u.TeV\n",
    "e_max_fit = 10 * u.TeV\n",
    "for dataset in ana_1d.datasets:\n",
    "    mask_fit = dataset.counts.energy_mask(emin=e_min_fit, emax=e_max_fit)\n",
    "    dataset.mask_fit = mask_fit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Fit failed for time bin between 53343.92234009259 and 53343.94186555556, setting NaN.\n",
      "Fit failed for time bin between 53343.95421509259 and 53343.97369425926, setting NaN.\n",
      "Fit failed for time bin between 53345.96198129629 and 53345.98149518518, setting NaN.\n",
      "Fit failed for time bin between 53347.913196574074 and 53347.93271046296, setting NaN.\n"
     ]
    }
   ],
   "source": [
    "lc_maker_1d = LightCurveEstimator(\n",
    "    ana_1d.datasets, source=\"crab\", reoptimize=False\n",
    ")\n",
    "lc_1d = lc_maker_1d.run(e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Compare results\n",
    "\n",
    "Finally we compare the result for the 1D and 3D lightcurve in a single figure:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/deil/work/code/gammapy-docs/build/dev/gammapy/gammapy/time/lightcurve.py:145: RuntimeWarning: All-NaN slice encountered\n",
      "  np.nanmax(np.concatenate((y[~is_ul], yul[is_ul])))\n",
      "/Users/deil/work/code/gammapy-docs/build/dev/gammapy/gammapy/time/lightcurve.py:146: RuntimeWarning: All-NaN slice encountered\n",
      "  - np.nanmin(np.concatenate((y[~is_ul], yul[is_ul])))\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11db7fe10>"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "ax = lc_1d.plot(marker=\"o\", label=\"1D\")\n",
    "lc_3d.plot(ax=ax, marker=\"o\", label=\"3D\")\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## LC estimation by night\n",
    "We define the time intervals to compute the LC by night, here three nights."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_intervals = [\n",
    "    Time([53343.5, 53344.5], format=\"mjd\", scale=\"utc\"),\n",
    "    Time([53345.5, 53346.5], format=\"mjd\", scale=\"utc\"),\n",
    "    Time([53347.5, 53348.5], format=\"mjd\", scale=\"utc\"),\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Compute 1D LC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Fit failed for time bin between 53343.5 and 53344.5, setting NaN.\n",
      "Fit failed for time bin between 53345.5 and 53346.5, setting NaN.\n",
      "Fit failed for time bin between 53347.5 and 53348.5, setting NaN.\n"
     ]
    }
   ],
   "source": [
    "lc_maker_1d_bynight = LightCurveEstimator(\n",
    "    ana_1d.datasets,\n",
    "    time_intervals=time_intervals,\n",
    "    source=\"crab\",\n",
    "    reoptimize=False,\n",
    ")\n",
    "lc_1d_bynight = lc_maker_1d_bynight.run(\n",
    "    e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Compute 3D LC"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "lc_maker_3d_bynight = LightCurveEstimator(\n",
    "    ana_3d.datasets,\n",
    "    time_intervals=time_intervals,\n",
    "    source=\"crab\",\n",
    "    reoptimize=True,\n",
    ")\n",
    "lc_3d_bynight = lc_maker_3d_bynight.run(\n",
    "    e_ref=1 * u.TeV, e_min=1.0 * u.TeV, e_max=10.0 * u.TeV\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Compare LC by night"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "ax = lc_1d_bynight.plot(marker=\"o\", label=\"1D\")\n",
    "lc_3d_bynight.plot(ax=ax, marker=\"o\", label=\"3D\")\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.legend.Legend at 0x11e3bbda0>"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "ax = lc_1d_bynight.plot(marker=\"o\", label=\"1D\")\n",
    "lc_3d_bynight.plot(ax=ax, marker=\"o\", label=\"3D\")\n",
    "plt.legend()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.0"
  },
  "nbsphinx": {
   "orphan": true
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
